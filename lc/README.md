# Overview

Those are my solutions to the problems on [LeetCode](https://leetcode.com/). I will also try to provide explanations for the problems I solve. Trying to land a good job in the tech industry.


## How to understand the problem quickly?

1. Read the Problem Statement Carefully
Identify the Problem Type: Determine if it's about arrays, strings, graphs, dynamic programming, etc.
Understand the Goal: Clearly define what the problem is asking. What is the input, and what output is expected?
2. Break Down the Example Cases
Work Through Examples: Manually walk through the provided examples to see how the input is transformed into the output.
Edge Cases: Think about edge cases (e.g., empty input, single-element arrays, negative numbers).
3. Clarify Constraints
Check Limits: Note the constraints, like array sizes or value ranges, which hint at the time complexity needed.
Infer Optimization: If constraints are large, an O(n²) solution might be inefficient.
4. Restate the Problem
Simplify in Your Words: Explain the problem in simpler terms or draw it out to solidify your understanding.
5. Identify the Pattern or Algorithm
Common Patterns: Recognize common patterns like sliding windows, two-pointers, or recursion.
Think of Similar Problems: Relate it to problems you've seen before.
6. Plan Before You Code
Pseudo-code: Write a high-level outline of the solution.
Break it into Steps: Define clear steps or functions to solve sub-problems.
7. Practice!
The more problems you solve, the quicker you'll recognize patterns and approaches.

## How to solve the problem quickly?

1. Understand the Problem Thoroughly (2-5 minutes)
Quick Read: Understand the problem statement in one go.
Key Info Highlighting: Focus on inputs, expected outputs, and constraints.
Restate: Summarize the problem in your own words.
2. Classify the Problem Type (1-2 minutes)
Identify if it belongs to:
Arrays/Strings
Trees/Graphs
Dynamic Programming
Two Pointers/Sliding Window
Familiarity helps you quickly decide on an initial approach.
3. Develop an Approach (3-5 minutes)
Pattern Matching: Relate it to similar problems you’ve solved.
Think in Steps: Outline the algorithm before coding.
Choose the Best Data Structure: Sometimes, the right data structure simplifies the task (e.g., using stacks for balanced parentheses).
4. Optimize for Constraints (2-3 minutes)
Time Complexity Analysis: Choose an approach that fits within the constraints.
Avoid Brute Force: If n is large, an O(n²) solution won’t work efficiently.
5. Write Clean Code (5-10 minutes)
Code in Functions: Modularize for better readability.
Edge Cases First: Handle boundary conditions immediately.
Comment Key Steps: Helps if you need to debug.
6. Test and Refine (3-5 minutes)
Run Basic Tests: Use simple inputs first.
Edge Cases: Check minimum/maximum inputs, duplicates, or empty inputs.
Dry Run: Walk through the code with a complex example.
7. Learn from Mistakes
Review Solutions: Compare with the optimal solution after solving.
Pattern Recognition: Note common strategies (DFS for trees, memoization for DP).
Practice Tips for Speed:
Start with Easy Problems: Build confidence and pattern recognition.
Set a Timer: Practice solving within a set timeframe.
Daily Practice: Consistency helps identify patterns faster.
Review Mistakes: Understanding errors boosts problem-solving efficiency.

Note: Let's start with those tips and see how it goes. I will update this section as I learn more about the process.

## Where to start?

https://leetcode.com/explore/featured/card/leetcodes-interview-crash-course-data-structures-and-algorithms/ 